\documentclass[aip,jcp,reprint,footinbib]{revtex4-1}

\usepackage[utf8]{inputenc} % Unicode input encoding
\usepackage[T1]{fontenc} % Font encoding

\usepackage[utopia]{mathdesign}
\usepackage{erewhon}

\usepackage{inconsolata}
\usepackage[english]{babel} % English linebrakes, hyphenation etc.
\usepackage[%
	tracking=true,kerning=true,spacing=true,%
	stretch=10,shrink=10,%
	factor=1100,%
	]{microtype}
\microtypecontext{spacing=nonfrench}
	
\usepackage{graphicx}% Include figure files
\graphicspath{ {./img/} }

\usepackage{multirow}

\usepackage{csquotes}
\usepackage{parskip} % Change paragraph formatting parindent = 0, parskip > 0
\usepackage{bm}% bold math
\usepackage{mathtools}
\usepackage{xspace}
\usepackage{xcolor}

\DeclareMathAlphabet{\mathoms}{OMS}{cmsy}{m}{n}
\DeclareMathOperator{\bigO}{\ensuremath{\mathoms{O}}}

\usepackage{lipsum}
\usepackage{nopageno}
\usepackage{enumitem}
\setlist{nosep}

\raggedbottom
%\flushbottom

% Placeholders
\newcommand\plcite{{\color{red}\textbf{[???]}}\xspace}
\newcommand\plinfo{{\color[rgb]{0.929,0.694,0.125}\textbf{[info]}}\xspace}
\let\tt\texttt
\newcommand\psll{\texttt{psll}\xspace}

\usepackage{color}

\definecolor{lines_blue}{rgb}{0, 0.4470, 0.7410}
\definecolor{lines_red}{rgb}{0.8500, 0.3250, 0.0980}
\definecolor{lines_yellow}{rgb}{0.9290, 0.6940, 0.1250}
\definecolor{lines_purple}{rgb}{0.4940, 0.1840, 0.5560}
\definecolor{lines_green}{rgb}{0.4660, 0.6740, 0.1880}
\definecolor{lines_cyan}{rgb}{0.3010, 0.7450, 0.9330}
\definecolor{lines_burgundy}{rgb}{0.6350, 0.0780, 0.1840}

% Hyperref
\PassOptionsToPackage{anythingbreaks}{url}
% Hyper reference setup
\usepackage[%
bookmarks=false, hypertexnames=false,%
colorlinks, allcolors={black}, citecolor={black!80!white}, urlcolor={blue!50!black}, %
unicode, % Encode pdf as unicode
breaklinks=true, % Allow links to break lines
hyperfootnotes=false % Dont link footnotes (This does not work very well)
]{hyperref}%

\usepackage{listings}

% Bold "Listing"
\renewcommand{\lstlistingname}{\bfseries Listing}
\makeatletter
\def\fnum@lstlisting{%
  \lstlistingname
  \ifx\lst@@caption\@empty\else~\thelstlisting\normalfont\fi}%
\makeatother

% " , / , [ and ] keywords don't play nicely with other syntax
\lstdefinelanguage{psll} {%
otherkeywords={+,!,=,<=>,*,-,^,\#,?,_},
morekeywords={out,chr,arg,set,do,loop,def}, % ,range,len,nil
morekeywords={[2]append, roll}, % cheat with syntax highlighting for the only two defs
sensitive=false,
morecomment=[l]{//},%
morestring=[b]"
}

\lstdefinelanguage{pyra} {%
otherkeywords={+,!,=,<=>,*,\#,?},
morekeywords={out,chr,arg,set,do,loop},
sensitive=false
}

\makeatletter
\def\lst@visiblespace{{\color{black!10!white}.}}
\makeatother

\lstset{
  aboveskip=3mm,belowskip=3mm,%
  columns=flexible,%
  basicstyle={\small\ttfamily},%
  numberstyle={\scriptsize\ttfamily\color{black!25!white}},%
  keywordstyle=\color{lines_blue},%
  keywordstyle={[2]\color{orange}},%
  keywordstyle={[3]\color{red}},%
  commentstyle=\color{lines_green},%
  stringstyle=\color{lines_purple},%
  breaklines=false,
  numbersep=3pt,
  tabsize=2,
  captionpos=b,
%   frame=tb, % tb
  numbers=left,
  showspaces=true
}

\newcommand{\ilpsll}[1]{\lstinline[language=psll,columns=flexible]{#1}}
\newcommand{\ilruby}[1]{\lstinline[language=ruby,columns=flexible]{#1}}

% Break links anywhere
\renewcommand{\UrlBreaks}{\do\/\do\a\do\b\do\c\do\d\do\e\do\f\do\g\do\h\do\i\do\j\do\k\do\l\do\m\do\n\do\o\do\p\do\q\do\r\do\s\do\t\do\u\do\v\do\w\do\x\do\y\do\z\do\A\do\B\do\C\do\D\do\E\do\F\do\G\do\H\do\I\do\J\do\K\do\L\do\M\do\N\do\O\do\P\do\Q\do\R\do\S\do\T\do\U\do\V\do\W\do\X\do\Y\do\Z\do\0\do\1\do\2\do\3\do\4\do\5\do\6\do\7\do\8\do\9\do\-\do\:\do\.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\preprint{AIP/123-QED}

% \title{Design and implementation of \psll\ -- Lisp-like programming language which compiles to Pyramid Scheme}
\title{Local-macro-driven metalanguage as a platform for writing large Pyramid Scheme programs}

\def\crl{Department of Chemistry, University of Oxford, Chemistry Research Laboratory, Oxford OX1 3TA, U.K.}
\def\samueli{UCLA Samueli School of Engineering, University of California, Los Angeles, 7400 Boelter Hall, Los Angeles, CA 90095, United States}
\author{Marcin~Konowalczyk}\email{marcin.konow@lczyk.xyz}\affiliation{\crl}\affiliation{\samueli}

\date{\today}

\begin{abstract}
In this work we present a metalanguage which allows simpler writing of Pyramid Scheme programs. We first introduce the Pyramid Scheme itself, pointing out some more interesting features. We then proceed to define a base lisp-like notation for Pyramid Scheme (called \psll), and expand on it with local macros (and semi-local) macro expansions which allow for higher-level constructs. Notably, we introduce strings, arrays and preprocessor definitions which can be used akin to functions. The entire project is available on GitHub at \href{https://github.com/MarcinKonowalczyk/psll-lang}{MarcinKonowalczyk/psll-lang}.
\end{abstract}

\keywords{syntax tree; pyramids; compilation; horizontal gene transfer; sorting; code golf}

\maketitle

\section{Introduction}

In ancient Egypt, pyramids were constructed as the resting places of deceased pharaos, containing not only their mummified remains but also an assortment of keywords and type literals the pharaoh will need in their journey though afterlife. Pyramid Scheme (PS) is a variant of the Scheme dialect of Lisp, which honours these ancient traditions and accompanies \emph{us} thorough our journey of computation.

PS was designed by Conor O'Brien, in the early 2017 (date of the earliest commit to the GitHub repository).~\cite{pyra_git} It is a turing-complete esoteric programming language (esolang)~\,\cite{pyra_esolang} which uses tree-like, as opposed to a serial code structure. Compilers make use of an intermediate representation of the language in the form of an abstract syntax tree (AST).~\cite{cooper2011} In contrast to most contemporary languages / frameworks, which build on top of the existing infrastructure to create \enquote{the stack} of software,~\cite{cantrill2017,muratori2018} Pyramid Scheme aims to shed any unnecessary abstractions, including that of the AST. The computation in Pyramid scheme is therefore represented as a literal syntax tree (LST) of ascii-art pyramidal constructs.

Pyramid Scheme is supported by the \enquote{Try It Online!} repository of online interpreters,~\cite{tio} and, like many other esolangs, has been featured in many Code Golfing challenges.~\cite{golf_se}

\section{Pyramid Scheme}

% aboveskip=0pt,belowskip=0pt
\begin{lstlisting}[float,language=pyra,
    label=lst:pyra_simple, caption={
        A simple Pyramid Scheme program. It takes one input from \tt{stdin} -- \ilpsll{(set x (\# stdin))}, increments it by one -- \ilpsll{(set x (+ x 1))} and prints the result computation to the command line.
}]
      ^ ^     ^             ^      ^      ^    ^
     ^-/ \   / \           / \    / \    / \   -^
    ^-/out\ /set\         /out\  /out\  /out\  / \
   / \-----^-----^       ^----- ^----- ^----- /out\
  /set\   /x\   /+\     / \    / \    / \    ^-----
 ^-----^  ---  ^---^   /chr\  /chr\  /chr\  /x\
/x\   /#\     /x\ /1\ ^----- ^----- ^-----  ---
---  ^---     --- ---/ \    / \    / \
    /l\             /43 \  /49 \  /61 \
   /ine\            -----  -----  -----
   -----
\end{lstlisting}

The original and, so far, the only implementation of PS is written in Ruby.~\cite{pyra_git} The LST of the program is first parsed and then mapped to a recursive evaluation chain. An example of one such program can be seen in Listing~\ref{lst:pyra_simple}.

PS parser reads the body of each pyramid verbatim, concatenated line by line.\footnote{Hence, for example, the bottom pyramid in the first stack in Listing~\ref{lst:pyra_simple} contains the (semi)keyword \tt{line}, as opposed to two words: \tt{l} and \tt{ine}.} The parser begins at the tip (\tt{\^}), and walks down the left (\tt{/}) and the right (\tt{\textbackslash}) side, collecting the characters in-between. When the two sides run out, it first checks for the presence of the pyramid base (\tt{-}),\footnote{Note that the base of the pyramid is a dash (\tt{0x2d}), not an underscore.} and then for the tips of the child pyramids, if present. The pyramids may connect \emph{only} on these corners, such that, for example, the first pyramid with \tt{chr} (which constructs a character \tt{+} to be printed) in Listing~\ref{lst:pyra_simple} rightfully does not consider the pyramid \tt{1} of the \tt{set} branch as its child.

Note, however, that this allows for an existence of direct connection between neighbouring branches of the LST -- in Listing~\ref{lst:pyra_simple}, for example, the first print statement (\tt{out} keyword), shares the node \tt{x} with its neighbouring branch. This is an interesting parallel to the phenomenon of the lateral gene transfer observed in genetics, and suggests a more-proper description of the PS to be that of a Ewok village syntax tree (EVST).\cite{keeling2008,smbc} Although this is undoubtedly one of the more interesting and powerful features of PS, it has not yet been implemented in the project described herein shortly, and therefore will not be considered further, but left for future work.

The specification of the pyramid structure does not preclude the existence of a pyramid with no content. Such a 0-height pyramid is falsey and evaluates to 0.~\footnote{The term \enquote{0-height} can be ambiguous since the pyramid itself has height of 2 characters. In this work the pyramid's height, however, is the number of lines of the text in its body.}~\cite{psnegation} A pyramid with no content \emph{does} however both evaluate its children, and pass them as an its output. This make the 0-height pyramid an important construct for code packing, as can be seen in the first branch in Listing~\ref{lst:pyra_simple}

There are two types operators in PS: ones which implicitly evaluate both of their children, as well as those which do this only under certain circumstances. The first group maps very closely to its underlying Ruby implementation. There are basic binary arithmetic and comparison operators: \tt{+}, \tt{*}, \tt{-}, \tt{/}, \tt{\^}, \tt{=}, \tt{!} and \tt{<=>}. Keyword \tt{out} prints all of its inputs and \tt{chr} converts number to a character. The keyword \tt{arg} indexes arrays (or input arguments), and keywords \tt{\#} and \tt{"} convert back and forth from and to a string. \tt{\#} character also allows one prompt user for input if given a (semi)keyword \tt{line}.~\footnote{Words \tt{line}, (as well as \tt{stdin}, \tt{readline}) are referenced to as \emph{semi}keywords since they have a keyword meaning only when they're an input of the \# command.}~\cite{pyra_git}

The second group of operators conditionally evaluates only one of their children. \tt{set} sets the variable denoted by its left child to the evaluated right one. \tt{loop} and \tt{do} evaluate the right child subtree as long as the left one evaluates to true (with the difference being when is the check made -- before and after right subtree evaluation respectively). Finally \tt{?} keyword evaluates the right subtree only if the left one evaluates to true, else it evaluates to zero.

\section{psll}

In order to assist the programmer in harnessing the power of Pyramid Scheme, we introduce a meta-language - Pyramid Scheme lisp-like notation (\psll).

\textbf{Bracket structure} Lets consider the LST approximation of the full EVST structure of Pyramid Scheme. Every node of the LST has at most two children. We will express each node as a bracket containing exactly three, space-separated words, brackets or null-markers (\ilpsll{_}). Only the first entry is allowed to be a word. A simple statement in such notation may be \ilpsll{(set (x _ _) (+ (x _ _) (1 _ _))} -- the second branch from Listing~\ref{lst:pyra_simple}, increment variable \tt{x} by one. Although this is sufficient to re-serialize any PS program, one quickly notes its the cumbersomeness of having to specify the empty space explicitly. Therefore we add a simple macro-like expansion where, firstly, each lone word in the 2\textsuperscript{nd} or 3\textsuperscript{rd} position is considered to be in a bracket of its own, and secondly each bracket with length of less than 3 is expanded up to the length of 3. Hence the increment branch can be written as \ilpsll{(set x (+ x 1))}, since \ilpsll{x} \textrightarrow \ilpsll{(x)} \textrightarrow \ilpsll{(x _ _)}. This also means that keywords with less than two arguments do not need to specify explicit null-markers for the second argument. Lastly \tt{//} denotes a comment. Hence, the program from Listing~\ref{lst:pyra_simple} can be written as:
\begin{lstlisting}[language=psll,
    label=lst:psll_simple, caption={
    LST approximation of the program from Listing~\ref{lst:pyra_simple} in simple \psll notation.
}]
(set x (# line)) // Get x from stdin
(out _ x) // Print x
(set x (+ x 1)) // Increment x
// Print "+1=" and then the value of x again
(out (chr 43)) (out (chr 49)) (out (chr 61)) (out x)
\end{lstlisting}
Note that the LST approximation has been applied, such that \tt{x} from \tt{out} and\tt{set} are now different. To get the code in Listing~\ref{lst:pyra_simple} the PS source has been modified by-hand post compilation.

This type of local macro expansion is at the core of \psll. Such macros do not add any expressive power to the language,\cite{krishnamurthi2019} but allow one to use higher-level constructs and simplify writing programs. All of the functionality, which will be described shortly, has been implemented by repeatedly leveraging a single python function which performs a depth-first walk through the AST and applies functions at the appropriate nodes (Listing~\ref{lst:tree_traversal}).

\begin{lstlisting}[language=python,
    label={lst:tree_traversal},caption={
    Core \psll function performing a depth-first walk through the abstract syntax tree and application of appropriate functions.
}]
def tree_traversal(ast, pre_fun=None, str_fun=None,
    post_fun=None, final_fun=None):
    ast2 = [] # Since, ast is immutable, build a new ast
    for node in ast:
        if node is None:
            ast2.append(node)
        elif is_string(node):
            ast2.append(str_fun(node) if str_fun else node)
        elif is_tuple(node):
            node = pre_fun(node) if pre_fun else node
            node = tree_traversal(node, pre_fun, str_fun, 
                post_fun, final_fun)
            node = post_fun(node) if post_fun else node
            ast2.append(node)
        else:
            raise TypeError
    ast2 = tuple(ast2)
    final_fun(ast2) if final_fun else None
    return ast2 # Return ast back as a tuple
\end{lstlisting}

\textbf{Implicit bracket expansion} Each bracket must have exactly three elements. For small expressions this is almost always the case, but becomes problematic for larger, flow-control and loop structures where each such expression can contain an arbitrarily large number of sub-expressions which would then have to be manually nested in empty subtrees. An overfull bracket one containing more than - one containing $>2$ other brackets, such as:
\begin{lstlisting}[language=psll,aboveskip=3pt,belowskip=-2pt,frame=none,numbers=none]
( (out 1) (out 2) (out 3) (out 4) (out 5) )
\end{lstlisting}
gets expanded as:
\begin{lstlisting}[language=psll,aboveskip=3pt,belowskip=-2pt,frame=none,numbers=none]
( (((out 1) (out 2))  ((out 3) (out 4)))  (out 5) )
( (((_ out 1) (_ out 2))  ((_ out 3) (_ out 4)))  (_ out 5) )
\end{lstlisting}
Each neighbouring pair or elements of the parent gets put together into a bracket, until the length of the parent is less than 2. Then, each bracket with exactly 2 other brackets has the empty-marker inserted as the first element. Note that the empty marker is a compiler-only keyword (python empty string) and it cannot be typed directly.\footnote{For completeness sake this will likely be implemented by reusing the underscore keyword, such that, for example, \tt{((out 1) (out 2))} could be then explicitly expanded in \psll as \tt{(\_ (\_ out 1) (\_ out 2))}} This results in a (literal) balanced binary tree in the final PS code, and so for a parent bracket of $N$ sub-expressions will result in a tree of containing $\bigO\left(\log_2\left(N\right)\right)$ pyramids.

\textbf{Expansion of binary operators} A similar type of expansion can be applied to a bracket where the first member is not a child bracket but a keyword. This is done only for all binary operator keywords (\tt{+}, \tt{*} as well as \tt{-}, \tt{/}, \tt{\^}, \tt{=} and \tt{<=>}) in a left-associative (LA) fashion, such that:
\begin{lstlisting}[language=psll,aboveskip=3pt,belowskip=-2pt,frame=none,numbers=none]
(+ 1 2 3 4) // This
(out (+ (+ (+ 1 2) 3) 4) newline) // Becomes this
\end{lstlisting}
Addition and subtraction are commutative over the set of most possible inputs, and hence the exact order of operations does not usually matter (string multiplication overloads concatenation and that's not commutative). For a non-commutative operation, e.g. subtraction, the expansion order does matter. Hence, if the keyword is placed at the end of the bracket, a right-associative (RA) expansion is performed:
\begin{lstlisting}[language=psll,aboveskip=3pt,belowskip=-2pt,frame=none,numbers=none]
  (- 1 2 3 4) // This
  (- (- (- 1 2) 3) 4) // Does indeed expand into this
  (1 2 3 4 -) // But this
  (- 1 (- 2 (- 4 3))) // Expands to this instead
\end{lstlisting}
Note that the order of the last two elements is purposefully reversed, such that the RA expansion is symmetrical with respect to the LA one. For the sake of compatibility with non-expanded brackets, the following two are also allowed for all binary operators.
\begin{lstlisting}[language=psll,aboveskip=3pt,belowskip=-2pt,frame=none,numbers=none]
  (- 1 2) // 1 - 2 = -1
  (1 2 -) // 2 - 1 = +1
\end{lstlisting}

Finally, the \tt{out} keyword normally does not allow for output of more than 2 variables. In \psll the \tt{out} keywords can have any number of inputs, and it gets implicitly expanded to a chain of output statements: 
\begin{lstlisting}[language=psll,aboveskip=3pt,belowskip=-2pt,frame=none,numbers=none]
  (out a b c d e) // This
  (out a b) (out c d) (out e) // Becomes this
\end{lstlisting}
Note that this is different to teh left-associative expansion of the binary keywords above. There is no right-associative expansion of the \tt{out} keyword.

\textbf{String literals} Single characters can be created in the Pyramid Scheme memory with the \tt{chr} keyword (Ruby \tt{.to\textunderscore{}i.chr}). It is also possible to construct longer strings since Ruby's \enquote{\tt{+}} sign overloads string concatenation. The string \textit{\enquote{hello}} is therefore:
\begin{lstlisting}[language=psll,aboveskip=3pt,belowskip=-2pt,frame=none,numbers=none]
  (+ (chr 72) (chr 101) (chr 108) (chr 108) (chr 111))
\end{lstlisting}
Where the numbers are the decimal ascii codes for the respective letters, and a LA \tt{+} operator expansion has been assumed. \psll introduces string literals, such that \ilpsll{"hello"} expands into the above code.\footnote{Note that this is a very left-child heavy tree. To balance it, the above string could also be made by recursively concatenating its binary split. This will be implemented in the future.} The simplest "Hello, Sailor!" program in \psll is \ilpsll{(out "Hello, Sailor!")}.

\textbf{Array literals} 

\textbf{\tt{def} keyword}

Semi-local
\subsection{Optimisation}

\subsection{Sharp edges}\label{sec:sharp_edges}


Despite authors best efforts, this introduces some sharp edges into the language (see Section~\ref{sec:sharp_edges}).


As mentioned at the beginning of Section, the introduction of syntactic sugar into \psll introduces some edge cases which one ought to watch out for.

\textbf{Escape characters}
Because " is used for strings, and [ ] for arrays...


\section{Example programs}
\subsection{Pseudorandom number generation}

\begin{lstlisting}[language=psll,aboveskip=3mm,belowskip=3mm]
(set seed 312312)
(set div (^ 2 16)) // 16-bit divisor
(set prime 7) // Prime divisor
// Prime divisor is small because of modulo implementation

// Generate uniformly distributed random number between 0-1
// mod(prime*seed + current, 2^16)
(def roll (
    (set seed (+ (* seed prime) 1))
    (loop (<=> (<=> seed div) -1) (set seed (- seed div)))
    (set rand (/ seed div))
))

// Print 100 such numbers
(set i 0)
(do (<=> i 100) (
    (roll) (out rand "\n")
(set i (+ i 1))
))
\end{lstlisting}

\subsection{Bubble sort}

\begin{lstlisting}[language=psll,aboveskip=3mm,belowskip=3mm]
(set n (arg 999)) // Make nil value

// Array to be sorted
(set a [3 1 4 1 5 9 2 6 5 3 5])

// Get array length
// This will be: (len a N)
(set N 0) // Pointer into the array
// Increment pointer until goes off the end
(loop (! (= (arg a N) n)) (set N (+ N 1)))

// Append element of a in position q to b
(def append (set b (+ b (- ((arg a q) n) (n n)))))
// Usage: (set q ...) (append)

// Bubble sort the array
(do again (
    (set again 0)
    (set p 0) // Position pointer
    (loop (! (! (<=> p (- N 1)))) ( // For all pairs
    (set this (arg a p))
    (set next (arg a (+ p 1)))
    // This and next need swapping
    (set swap (! (<=> (<=> this next) -1)))
    (? swap ( // If swap
        (set again 1) // Will need to go again
        (set b []) // Start b as an empty array
        // Add prefix of a
        (set l 0)
        (loop (= (<=> l p) -1) (
            (set q l) (append)
        (set l (+ l 1))
        ))
        // Add two elements, swapped
        (set q (+ p 1)) (append)
        (set q (+ p 0)) (append)
        // Add suffix of a
        (set l (+ p 2))
        (loop (= (<=> l N) -1) (
            (set q l) (append)
        (set l (+ l 1))
        ))
        (set a b)
    ))
    (set p (+ p 1)) // Increment position pointer
    ))
    (out (* a ",") "\n") // Print a
))
(out "done")
\end{lstlisting}

\section{Conclusions and outlook}
\textit{\enquote{Program in Pyramid Scheme! Teach your friends! Have them teach \emph{their} friends! Then have those friends teach \emph{their} friends! ...}}

This is by no means a done project, so long as it is a platform for me to learn and have fun. I also believe tht the future direction of \psll poses some genuinely interesting computational problems, namely efficient code optimisation and performing more advanced code transformations. The language is currently not allowing one to leverage the full power of EVSTs of Pyramid Scheme, but instead uses the LST approximation. The goal is, indeed, to add this to the the language. This will, however, be a major milestone since the EV structure of the resulting syntax tree will require major restructuring of the internals of the compiler. At least initially, EV branching will be available only at the level of intermediate-representation optimisers. However, since one of the purposes of \psll is an esoteric flavour of code-golf, one might want to manually adjust the code structure, similarly to how the underscore keyword is used at the moment. Additional keywords, as well as their supporting architecture will therefore need to be introduced to be able to explicitly specify EV cross-branching structure.

There are a few major parts of \psll which need to be finished before that. Notably there are a few core bugs which any additional functionality would make only harder to track. These are detailed in \tt{README} in the main \psll repository and range from relatively harmless (\tt{def} inserts an extra empty pyramid) to major (\tt{()}) unduly pops the definition stack). There are also some minor support keywords which are yet due to be added. These are, for example, \tt{len} -- expanding to the equivalent of line 10 in Listing~\ref{lst:bubble_sort} and \tt{nil} -- initially expanding to \ilpsll{(set nil (arg 999))}, or something more robust, in the preamble. This is not to mention typical and necessary software project irks like ensuring the project has appropriate test coverage (currently at 69\%) and fighting code bloat (currently at approx 530 core lines + bash support).

Code golf involves writing a program in a freely-chosen programming language which performs a certain operation under some constraint. This usually comes in the form of the smallest number of characters in the source code and is a platform for one to either learn a new programming language, or explore the depths of an already known one. Code golfing provides one with a set of goals which is almost-orthogonal to what one finds in everyday programming, and therefore often sheds new light on old, seemingly well-known ideas. \psll caters to a new flavour of code-golfing. Large PS programs are not feasible to be written by hand, not to even mention the number of rewrites and code obfuscation which usually happens when golfing. Hence, all the golfing happens at the level of writing compiler and optimisation algorithms therein, rather than the code itself.\cite{psnegation_answer}

Finally, I think every programmer shares a certain latent interest in the underlying structure and of the languages they use every day. I would encourage them to scratch that itch. There are plenty of resources to start, but I am inclined to mirror the advice of Casey Muratori:~\cite{blow2020qna} \textit{\enquote{Look at all of the resources on these topics in in the following way: rather than reading what someone tells you about how to build a compiler (...) start programming one without knowing what you're doing (...) and see what you can learn. When you cannot make forward progress (...) [look for] solution to that particular problem you're having. (...) Now you have some context to evaluate what people what you (...) whereas if you read about stuff without ever actually having encountered a problem yet, then you're just gonna you have no idea [whether its valuable].}} If you really want a starting point though, I recommend David Beazley's ply and sly projects,~\cite{dbeaz2018,sly,ply} which are based on Yet Another Compiler-Compiler (YACC).\cite{levine1992}

\section*{Version notes}

\setlength{\abovedisplayskip}{3pt}
\setlength{\belowdisplayskip}{3pt}

At the time of writing, the commit SHA of the main Pyramid Scheme GitHub repo\cite{pyra_git} is:
\[
    \href{https://github.com/ConorOBrien-Foxx/Pyramid-Scheme/commit/fd183d296f08e0cba8bf55da907697eaf412f6a7}{\tt{fd183d296f08e0cba8bf55da907697eaf412f6a7}}
\]
and the \psll repo:\cite{psll_git}
\[
    \href{https://github.com/MarcinKonowalczyk/psll-lang/commit/ea6c6d2e9c8278cc752894a9aff43f7d44bd93a9}{\tt{ea6c6d2e9c8278cc752894a9aff43f7d44bd93a9}}
\]

The \psll repository also has all the latex and make files for this very paper. Short of fixing typos, the text will not be modified after the submission.

\psll has been written in python >3.6. The only non-core library it depends on is \tt{more-itertools} version, at least, 8.5.0. This dependency was thought to be appropriate since this work led to a pull request to \tt{more-itertools}, added in version 8.5.0.\cite{more_itertools}

Pyramid Scheme is written in pure Ruby. At the time of witting it works in Ruby version 3.0.0p0 (2020-12-25 revision 95aff21468)

\tt{bash} is the the Dorian Gray of programming languages -- timeless.

\section*{Acknowledgements}

I would like to thank Blaine Rodgers and Samuel Hutton for discussions and helpful comments on the manuscript, as well as Jonathan Blow and David Beazley, for sparking a long-lasting interest in programming languages.

Last but not least, I would also like to cordially thank \emph{you} dear reader. You have made it! Thank you for reading!

\nocite{*}
\bibliographystyle{unsrt}
\bibliography{sigbovik-psll.bib}

% \clearpage
\onecolumngrid
\begin{lstlisting}[
    language=pyra,frame=t,
    aboveskip=3mm,belowskip=3mm,
    basicstyle={\footnotesize\ttfamily},
    numberstyle={\tiny\ttfamily\color{black!25!white}},
    label=lst:bubble_sort,
    caption={
        Bubble sort in Pyramid Scheme. Compiled with \tt{--full-names} and \tt{-co} (considerate optimisation) flags.
    }]
     ^            ^       ^ ^               ^                               ^
    / \          ^-      /l\-              ^-                              / \
   /set\        ^-      /oop\             / \                             /out\
  ^-----^      ^-      ^-----^           /   \                           ^-----
 /n\   / \    ^-      /!\   / \         / do  \                         / \
 ---  /arg\  ^-      ^---  /set\       ^-------^                       /   \
     ^----- ^-      /=\   ^-----^     / \     / \                     /  +  \
    / \    ^-      ^---^ /N\   /+\   /   \   /   \                   ^-------^
   /999\  ^-      / \ /n\---  ^---^ /again\ /     \                 / \     / \
   ----- / \     /arg\---    /N\ /1\-------/       \               / + \   /chr\
        /   \   ^-----^      --- ---      /         \             ^-----^  -----^
       /     \ /a\   /N\                 /           \           / \   / \     / \
      /       \---   ---                /             \         /   \ /chr\   /101\
     ^---------^                       /               \       /  +  \-----^  -----
    / \       / \                     /                 \     ^-------^   / \
   /set\     /set\                   ^-------------------^   / \     / \ /110\
  ^-----^   ^-----^                 / \                 / \ /chr\   /chr\-----
 /a\   / \ /N\   /0\               /   \               /   \-----^  -----^
 ---  /   \---   ---              /     \             /     \   / \     / \
     /     \                     /       \           /       \ /100\   /111\
    /   +   \                   ^---------^         /         \-----   -----
   ^---------^                 / \       / \       /           \
  / \       / \               /set\     /set\     /             \
 ^---^     /   \             ^-----^   ^-----^   ^---------------^
/3\ /1\   /  +  \           / \   /0\ /p\   /0\ / \             / \
--- ---  ^-------^         /   \  --- ---   ---/   \           /out\
        / \     / \       /again\             /     \         ^-----^
       ^---^   /   \      -------            /       \       /*\   / \
      /4\ /1\ /     \                       /         \     ^---^ /chr\
      --- ---/   +   \                     /   loop    \   /a\ / \-----^
            ^---------^                   ^-------------^  ---/chr\   / \
           / \       / \                 /!\           / \    -----^ /10 \
          ^---^     /   \               ^---          /   \       / \-----
         /5\ /9\   /  +  \             /!\           /     \     /44 \
         --- ---  ^-------^           ^---          /       \    -----
                 / \     / \         / \           ^---------^
                ^---^   /   \       /<=>\         / \       / \
               /2\ /6\ /     \     ^-----^       /   \     /set\
               --- ---/   +   \   /p\   /-\     /     \   ^-----^
                     ^---------^  ---  ^---^   /       \ /p\   /+\
                    / \       / \     /N\ /1\ /         \---  ^---^
                   ^---^     /   \    --- ---/           \   /p\ /1\
                  /5\ /3\   /  -  \         /             \  --- ---
                  --- ---  ^-------^       /               \
                          / \     / \     /                 \
                         ^---^   ^---^   /                   \
                        /5\ /0\ /0\ /0\ /                     \
                        --- --- --- ---/                       \
                                      /                         \
                                     /                           \
                                    /                             \
                                   /                               \
                                  ^---------------------------------^
                                 / \                               / \
                                /   \                             /   \
                               /     \                           /     \
                              /       \                         /       \
                             /         \                       /         \
                            /           \                     /           \
                           /             \                   ^-------------^
                          ^---------------^                 / \           / \
                         / \             / \               /set\         / ? \
                        /   \           /   \             ^-----^       ^-----^
                       / set \         / set \           /s\   /!\     /s\   / \
                      ^-------^       ^-------^         /wap\ ^---    /wap\ /   \
                     /t\     / \     /n\     / \        -----/ \      -----/     \
                    /his\   /arg\   /ext\   /arg\           /   \         /       \
                    -----  ^-----^  -----  ^-----^         / <=> \       /         \
                          /a\   /p\       /a\   /+\       ^-------^     /           \
                          ---   ---       ---  ^---^     / \     / \   /             \
                                              /p\ /1\   /<=>\   /-1 \ /               \
                                              --- ---  ^-----^  -----/                 \
                                                      /t\   /n\     /                   \
                                                     /his\ /ext\   /                     \
                                                     ----- -----  /                       \
                                                                 /                         \
                                                                /                           \
                                                               /                             \
                                                              /                               \
                                                             /                                 \
                                                            /                                   \
                                                           /                                     \
                                                          /                                       \
                                                         /                                         \
                                                        ^-------------------------------------------^
                                                       / \                                         / \
                                                      /   \                                       /   \
                                                     /     \                                     /     \
                                                    /       \                                   /       \
                                                   /         \                                 ^---------^
                                                  /           \                               / \       / \
                                                 /             \                             /   \     /set\
                                                /               \                           /     \   ^-----^
                                               /                 \                         /       \ /a\   /b\
                                              /                   \                       /         \---   ---
                                             /                     \                     /           \
                                            /                       \                   /             \
                                           /                         \                 ^---------------^
                                          /                           \               / \             / \
                                         /                             \             /set\           /   \
                                        /                               \           ^-----^         /     \
                                       /                                 \         /l\   /+\       /       \
                                      /                                   \        ---  ^---^     /         \
                                     /                                     \           /p\ /2\   /   loop    \
                                    /                                       \          --- ---  ^-------------^
                                   /                                         \                 / \           / \
                                  /                                           \               /   \         /   \
                                 ^---------------------------------------------^             /  =  \       /     \
                                / \                                           / \           ^-------^     /       \
                               /   \                                         /   \         / \     / \   /         \
                              /     \                                       /     \       /<=>\   /-1 \ ^-----------^
                             /       \                                     /       \     ^-----^  -----/ \         / \
                            /         \                                   /         \   /l\   /N\     /   \       /set\
                           /           \                                 /           \  ---   ---    /     \     ^-----^
                          /             \                               /             \             /       \   /l\   /+\
                         /               \                             /               \           ^---------^  ---  ^---^
                        /                 \                           /                 \         / \       ^-      /l\ /1\
                       /                   \                         ^-------------------^       /set\     / \      --- ---
                      /                     \                       / \                 / \     ^-----^   /set\
                     ^-----------------------^                     /   \               /   \   /q\   /l\ ^-----^
                    / \                     / \                   /     \             /     \  ---   ---/b\   /+\
                   /   \                   /   \                 /       \           /       \          ---  ^---^
                  /     \                 /     \               /         \         /         \             /b\ / \
                 /       \               /       \             ^-----------^       ^-----------^            ---/   \
                ^---------^             ^---------^           / \         ^-      / \         ^-              /  -  \
               / \       / \           / \       / \         /set\       / \     /set\       / \             ^-------^
              /set\     /set\         /set\     /   \       ^-----^     /set\   ^-----^     /set\           / \     / \
             ^-----^   ^-----^       ^-----^   /     \     /q\   /+\   ^-----^ /q\   /+\   ^-----^         ^---^   ^---^
            / \   /1\ /b\   / \     /l\   /0\ /       \    ---  ^---^ /b\   /+\---  ^---^ /b\   /+\       / \ /n\ /n\ /n\
           /   \  --- ---  /   \    ---   ---/         \       /p\ /1\---  ^---^   /p\ /0\---  ^---^     /arg\--- --- ---
          /again\         /  -  \           /   loop    \      --- ---    /b\ / \  --- ---    /b\ / \   ^-----^
          -------        ^-------^         ^-------------^                ---/   \            ---/   \ /a\   /q\
                        / \     / \       / \           / \                 /  -  \             /  -  \---   ---
                       ^---^   ^---^     /   \         /   \               ^-------^           ^-------^
                      /0\ /0\ /0\ /0\   /  =  \       /     \             / \     / \         / \     / \
                      --- --- --- ---  ^-------^     /       \           ^---^   ^---^       ^---^   ^---^
                                      / \     / \   /         \         / \ /n\ /n\ /n\     / \ /n\ /n\ /n\
                                     /<=>\   /-1 \ ^-----------^       /arg\--- --- ---    /arg\--- --- ---
                                    ^-----^  -----/ \         / \     ^-----^             ^-----^
                                   /l\   /p\     /   \       /set\   /a\   /q\           /a\   /q\
                                   ---   ---    /     \     ^-----^  ---   ---           ---   ---
                                               /       \   /l\   /+\
                                              ^---------^  ---  ^---^
                                             / \       ^-      /l\ /1\
                                            /set\     / \      --- ---
                                           ^-----^   /set\
                                          /q\   /l\ ^-----^
                                          ---   ---/b\   /+\
                                                   ---  ^---^
                                                       /b\ / \
                                                       ---/   \
                                                         /  -  \
                                                        ^-------^
                                                       / \     / \
                                                      ^---^   ^---^
                                                     / \ /n\ /n\ /n\
                                                    /arg\--- --- ---
                                                   ^-----^
                                                  /a\   /q\
                                                  ---   ---
\end{lstlisting}
\end{document}